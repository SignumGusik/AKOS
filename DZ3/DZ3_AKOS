.data
result_msg: .asciz "Maximum n for 32-bit factorial: "

.text
.globl main

# Макрос для вызова подпрограммы вычисления факториала
.macro call_fact
    jal ra, fact
.end_macro 

# Главная функция
main:
    # Инициализация
    li s0, 0           # s0 = текущее значение n
    li s1, 0           # s1 = максимальное n без переполнения
    
main_loop:
    # Вызов подпрограммы вычисления факториала
    mv a0, s0
    call_fact
    
    # Проверка на переполнение (a1 != 0 означает переполнение)
    bnez a1, overflow_detected
    
    # Сохраняем успешное значение
    mv s1, s0
    
    # Увеличиваем n и продолжаем
    addi s0, s0, 1
    j main_loop

overflow_detected:
    # Вывод результата
    la a0, result_msg
    li a7, 4
    ecall
    
    mv a0, s1
    li a7, 1
    ecall
    
    # Завершение программы
    li a7, 10
    ecall

# Рекурсивная подпрограмма вычисления факториала
# Вход: a0 = n
# Выход: a0 = факториал(n), a1 = 0 (успех) или 1 (переполнение)
fact:
    # Пролог - сохраняем регистры на стеке
    addi sp, sp, -20
    sw ra, 16(sp)
    sw s0, 12(sp)
    sw s1, 8(sp)
    sw s2, 4(sp)
    sw s3, 0(sp)
    
    # Сохраняем входной аргумент
    mv s0, a0
    
    # Базовый случай: fact(0) = 1, fact(1) = 1
    li t0, 1
    beq s0, zero, base_case
    beq s0, t0, base_case
    
    # Рекурсивный вызов: fact(n-1)
    addi a0, s0, -1
    call_fact
    
    # Проверяем переполнение из рекурсивного вызова
    bnez a1, fact_overflow
    
    # Вычисляем n * fact(n-1)
    mv s1, a0          # s1 = fact(n-1)
    mv s2, s0          # s2 = n
    
    # Проверяем возможность умножения без переполнения
    # Если fact(n-1) > (2^32 - 1) / n, то будет переполнение
    li t0, 0xFFFFFFFF  # Максимальное 32-битное значение
    divu t1, t0, s2    # t1 = максимальное значение до переполнения
    
    # Если fact(n-1) > максимального значения, переполнение
    bgtu s1, t1, multiplication_overflow
    
    # Выполняем умножение
    mul a0, s1, s2
    li a1, 0           # Успех
    j fact_epilogue

base_case:
    li a0, 1
    li a1, 0           # Успех
    j fact_epilogue

multiplication_overflow:
    li a0, 0
    li a1, 1           # Переполнение
    j fact_epilogue

fact_overflow:
    # Просто пробрасываем флаг переполнения
    li a0, 0
    li a1, 1
    j fact_epilogue

fact_epilogue:
    # Эпилог - восстанавливаем регистры
    lw s3, 0(sp)
    lw s2, 4(sp)
    lw s1, 8(sp)
    lw s0, 12(sp)
    lw ra, 16(sp)
    addi sp, sp, 20
    ret
